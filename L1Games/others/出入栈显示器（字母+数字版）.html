<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>✨ 入栈出栈演示器 ✨</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #f8f0fe 0%, #e6d4ff 100%); /* Light lavender gradient */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        h1 {
            color: #6a1b9a; /* Deep purple */
            text-align: center;
            font-size: 2.8em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            animation: fadeInDown 1s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #input-container {
            width: 100%;
            max-width: 800px;
            margin-bottom: 30px;
        }

        .input-section {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .input-section:first-child {
            animation: fadeInUp 1s 0.2s ease-out backwards;
        }

        .input-section:last-child {
            animation: fadeInUp 1s 0.4s ease-out backwards;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        input[type="text"] {
            padding: 12px 15px;
            border: 2px solid #c5a6e0;
            border-radius: 25px;
            font-size: 1em;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            flex-grow: 1;
            min-width: 200px;
        }

        input[type="text"]:focus {
            border-color: #9c27b0;
            box-shadow: 0 0 8px rgba(156, 39, 176, 0.3);
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #ff8a65 0%, #ff7043 100%);
            color: white;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transition: transform 0.2s ease, background 0.3s ease, box-shadow 0.2s ease;
        }

        button:hover {
            transform: translateY(-3px) scale(1.05);
            background: linear-gradient(135deg, #ff7043 0%, #ff5722 100%);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        button:active {
            transform: translateY(-1px) scale(1.02);
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: flex-end; /* Align bottoms for stack to appear grounded */
            flex-wrap: wrap;
            gap: 30px;
            margin-top: 20px;
            width: 100%;
            max-width: 900px;
            animation: fadeInUp 1s 0.6s ease-out backwards;
        }

        .data-structure {
            padding: 20px;
            min-height: 250px; /* Increased min-height for better visual */
            text-align: center;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transition: box-shadow 0.3s ease;
            flex: 1;
            position: relative;
            display: flex; /* Added for title positioning and item container control */
            flex-direction: column; /* Stack title and item-container vertically */
        }
        .data-structure:hover {
            box-shadow: 0 12px 24px rgba(0,0,0,0.2);
        }

        .data-structure-title {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 20px; /* More space below title */
            display: block;
        }

        .queue {
            background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
            border: 2px solid #4dd0e1;
            min-width: 220px;
        }
        .queue .data-structure-title { color: #00796b; }

        .stack {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
            /* Bucket style borders */
            border-left: 5px solid #c2185b;
            border-right: 5px solid #c2185b;
            border-bottom: 5px solid #c2185b;
            border-top: 3px dashed #f06292; /* Open top visual */
            border-radius: 10px 10px 3px 3px; /* Rounded top, sharper bottom */
            min-width: 180px; /* Narrower for bucket effect */
            max-width: 200px;
            padding-top: 15px; /* Space for title */
            justify-content: flex-end; /* Align item container to bottom */
        }
        .stack .data-structure-title {
            color: #c2185b;
            /* Positioned by flex layout of .data-structure */
        }

        .item-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            flex-grow: 1; /* Allow item container to take available space */
            justify-content: flex-start; /* For queues, items start from top */
            padding-top: 10px; /* Add some padding at the top of item list */
        }
        .stack .item-container {
            flex-direction: column-reverse; /* New items at the "top" (visually top of list) */
            justify-content: flex-start; /* Items stack upwards from the bottom entry point */
            padding-bottom: 5px; /* Ensure some space at the very bottom of stack visual */
        }


        .data-structure span {
            border: 1px solid rgba(0,0,0,0.1);
            padding: 10px 15px; /* Slightly larger items */
            margin: 0;
            border-radius: 8px;
            display: inline-block;
            background-color: white;
            color: #333;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 1;
            transform: scale(1);
            width: 70%; /* Items in stack/queue don't span full width */
            max-width: 100px; /* Max width for items */
        }
        
        /* 区分数字和字母的样式 */
        .data-structure span.number {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
        }
        
        .data-structure span.letter {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
        }
        
        .stack .item-container span {
             width: 85%; /* Items in stack can be a bit wider relative to container */
        }


        /* Generic item enter animation (used for initial load) */
        .item-enter-initial {
            animation: itemEnterInitialAnim 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        @keyframes itemEnterInitialAnim {
            0% { opacity: 0; transform: scale(0.5) translateY(20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }

        /* Animation for item exiting input-queue */
        .item-exit-input {
            animation: itemExitInputAnim 0.4s ease-out forwards;
            /* Make it move towards stack area */
        }
        @keyframes itemExitInputAnim {
            0% { opacity: 1; transform: translateX(0) scale(1); }
            /* Adjust X/Y to aim for stack top visually */
            100% { opacity: 0; transform: translateX(40px) translateY(-20px) scale(0.7); }
        }

        /* Animation for item entering stack (dropping in) */
        .item-enter-stack {
            animation: itemEnterStackAnim 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        @keyframes itemEnterStackAnim {
            /* Starts from above, as if dropped */
            0% { opacity: 0; transform: translateY(-40px) scale(0.7); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* Animation for item exiting stack (lifting out) */
        .item-exit-stack {
            animation: itemExitStackAnim 0.4s ease-out forwards;
        }
        @keyframes itemExitStackAnim {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            /* Lifts up from stack */
            100% { opacity: 0; transform: translateY(-50px) scale(0.7); }
        }

        /* Animation for item entering output-queue (sliding from left) */
        .item-enter-output {
            animation: itemEnterOutputAnim 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        @keyframes itemEnterOutputAnim {
            /* Starts from left, as if coming from stack */
            0% { opacity: 0; transform: translateX(-40px) scale(0.7); }
            100% { opacity: 1; transform: translateX(0) scale(1); }
        }


        #button-area {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            animation: fadeInUp 1s 0.8s ease-out backwards;
        }
        #button-area button {
            background: linear-gradient(135deg, #81c784 0%, #4caf50 100%);
        }
        #button-area button:hover {
            background: linear-gradient(135deg, #66bb6a 0%, #43a047 100%);
        }

    </style>
</head>
<body>
    <h1>✨ 入栈出栈演示器 ✨</h1>

    <div id="input-container">
        <div class="input-section">
            <input type="text" id="input-numbers" placeholder="输入数字序列, 如 1,2,3">
            <button id="confirm-numbers">🔢 确认数字</button>
        </div>
        <div class="input-section">
            <input type="text" id="input-letters" placeholder="输入字母序列, 如 a,b,c">
            <button id="confirm-letters">🔤 确认字母</button>
        </div>
    </div>

    <div class="container">
        <div class="queue data-structure" id="input-queue-container">
            <span class="data-structure-title">🧸 待入栈</span>
            <div class="item-container" id="input-queue-items"></div>
        </div>
        <div class="stack data-structure" id="stack-container">
            <span class="data-structure-title">📚 栈</span>
            <div class="item-container" id="stack-items"></div>
        </div>
        <div class="queue data-structure" id="output-queue-container">
            <span class="data-structure-title">🎉 已出栈</span>
            <div class="item-container" id="output-queue-items"></div>
        </div>
    </div>

    <div id="button-area">
        <button id="push-button">🚀 入栈</button>
        <button id="pop-button">🎈 出栈</button>
    </div>

    <script>
        // 获取DOM元素
        const inputNumbersInput = document.getElementById('input-numbers');
        const inputLettersInput = document.getElementById('input-letters');
        const confirmNumbersButton = document.getElementById('confirm-numbers');
        const confirmLettersButton = document.getElementById('confirm-letters');
        const inputQueueItems = document.getElementById('input-queue-items');
        const stackItems = document.getElementById('stack-items');
        const outputQueueItems = document.getElementById('output-queue-items');
        const pushButton = document.getElementById('push-button');
        const popButton = document.getElementById('pop-button');

        // 数据存储 - 每个元素是对象，包含值和类型
        let itemsQueue = [];  // 待入栈队列
        let stackArray = [];  // 栈
        let outputArray = []; // 已出栈队列
        const ANIMATION_DURATION = 400; // 动画持续时间(ms)
        const ENTER_ANIMATION_DURATION = 500;

        // 渲染元素到容器
        function renderItems(container, itemsArray, isStack = false) {
            container.innerHTML = '';
            const itemsToRender = itemsArray;

            itemsToRender.forEach((item) => {
                const span = document.createElement('span');
                span.textContent = item.value;
                // 根据类型添加不同的样式类
                span.classList.add(item.type);
                container.appendChild(span);
            });
        }
        
        // 渲染所有区域
        function renderAll() {
            renderItems(inputQueueItems, itemsQueue);
            renderItems(stackItems, stackArray, true);
            renderItems(outputQueueItems, outputArray);
        }

        // 处理数字输入
        confirmNumbersButton.addEventListener('click', () => {
            const inputValue = inputNumbersInput.value.trim();
            if (inputValue) {
                const numbers = inputValue.split(',')
                                  .map(s => s.trim())
                                  .filter(s => s !== '')
                                  .map(Number)
                                  .filter(n => !isNaN(n));
                
                // 将数字添加到待入栈队列，标记类型为number
                numbers.forEach(num => {
                    itemsQueue.push({ value: num, type: 'number' });
                });
            }
            inputNumbersInput.value = '';
            renderAll();
            
            // 添加初始动画
            Array.from(inputQueueItems.children).forEach((child, i) => {
                child.style.animationDelay = `${i * 0.08}s`;
                child.classList.add('item-enter-initial');
                child.addEventListener('animationend', () => {
                    child.classList.remove('item-enter-initial');
                    child.style.animationDelay = '';
                }, { once: true });
            });
        });

        // 处理字母输入
        confirmLettersButton.addEventListener('click', () => {
            const inputValue = inputLettersInput.value.trim();
            if (inputValue) {
                const letters = inputValue.split(',')
                                 .map(s => s.trim())
                                 .filter(s => s !== '');
                
                // 将字母添加到待入栈队列，标记类型为letter
                letters.forEach(letter => {
                    itemsQueue.push({ value: letter, type: 'letter' });
                });
            }
            inputLettersInput.value = '';
            renderAll();
            
            // 添加初始动画
            Array.from(inputQueueItems.children).forEach((child, i) => {
                child.style.animationDelay = `${i * 0.08}s`;
                child.classList.add('item-enter-initial');
                child.addEventListener('animationend', () => {
                    child.classList.remove('item-enter-initial');
                    child.style.animationDelay = '';
                }, { once: true });
            });
        });

        // 入栈操作
        pushButton.addEventListener('click', () => {
            if (itemsQueue.length > 0) {
                const inputQueueChildren = Array.from(inputQueueItems.children);
                if (inputQueueChildren.length > 0) {
                    const firstItemVisual = inputQueueChildren[0];
                    firstItemVisual.classList.add('item-exit-input');

                    setTimeout(() => {
                        const item = itemsQueue.shift();
                        stackArray.push(item);
                        renderAll(); 

                        const stackChildren = Array.from(stackItems.children);
                        if (stackChildren.length > 0) {
                            const newItemInStackVisual = stackChildren[stackChildren.length - 1]; 
                            if (newItemInStackVisual) {
                                newItemInStackVisual.classList.add('item-enter-stack');
                                newItemInStackVisual.addEventListener('animationend', () => {
                                    newItemInStackVisual.classList.remove('item-enter-stack');
                                }, { once: true });
                            }
                        }
                    }, ANIMATION_DURATION);
                }
            } else {
                alert("🧸 待入栈队列是空的哦！");
            }
        });

        // 出栈操作
        popButton.addEventListener('click', () => {
            if (stackArray.length > 0) {
                const stackChildren = Array.from(stackItems.children);
                const topItemStackVisual = stackChildren[stackChildren.length - 1];

                if (topItemStackVisual) {
                    topItemStackVisual.classList.add('item-exit-stack');

                    setTimeout(() => {
                        const item = stackArray.pop();
                        outputArray.push(item);
                        renderAll(); 

                        const outputQueueChildren = Array.from(outputQueueItems.children);
                        if (outputQueueChildren.length > 0) {
                            const newItemInOutputVisual = outputQueueChildren[outputQueueChildren.length - 1];
                            newItemInOutputVisual.classList.add('item-enter-output');
                            newItemInOutputVisual.addEventListener('animationend', () => {
                                newItemInOutputVisual.classList.remove('item-enter-output');
                            }, { once: true });
                        }
                    }, ANIMATION_DURATION);
                }
            } else {
                alert("📚 栈是空的，不能出栈啦！");
            }
        });

        // 初始渲染
        renderAll();

    </script>
</body>
</html>
